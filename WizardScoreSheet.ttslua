-- Updates at https://github.com/nickoto/WizardTTS

-- Suggested Table
-- The Kraken Table by Lily - This table has lots of space.
-- https://steamcommunity.com/sharedfiles/filedetails/?id=1222553243&searchtext=

-- Image file URLs

-- Score sheet
-- http://cloud-3.steamusercontent.com/ugc/1017191772739558362/E9510AC04902B77F58B7A650074CB017666D9432/

-- Card faces
-- http://cloud-3.steamusercontent.com/ugc/1017191983753296471/DD08D6C50FC805E0089684B1046A13E9F56921CE/

-- Card backs
-- http://cloud-3.steamusercontent.com/ugc/1017191983753306789/0BBB4B7DA07DF35234DCB3E4E8E0CFB265FACC3C/

-- Optional play area -- you only really need to set up a scripting area.
-- http://cloud-3.steamusercontent.com/ugc/1017191983753364511/BD70A07CB819BC02D854183695DFACB1AED3DE27/


-- TODOS:
-- Remove only cards that were 'played' and valid. Put every other card back in the players hand.
-- Copy cards to cleanup into a different list. Then do the cleanup on that list.
    

-- Cards must be named as follows, one pair for each of the cards in a wizard deck.
-- As long as these cards are present the script should be able to figure out what
-- to do.
-- [A23456789TJQK][HCDS] or [1234][WJ]

-- GUID Configuration
-- If placing this object into a new board these are the GUIDs that the
-- script requires.
PlayAreaScriptingZone = '8fa5bc'

-- Game constants
MaxRounds = { 20, 20, 20, 15, 12, 10 }
DeckPosition = {x=34.26, y=1.09, z=0.0}
DiscardDeckPosition = {x=34.26, y=1.09, z=12.0}
BadPlayPosition = {x=34.26, y=1.09, z=-12.0}
SeatOrder = {'Red', 'Green', 'Pink', 'Orange', 'Blue', 'White' }

-- Game State "Machine"
State_Setup = 0
State_PickSuit = 1
State_Bid = 2
State_Play = 3
State_Done = 4

-- User Interface Stuff
NameLabels = { }
SuitLabels = { }
ScoreLabels = { }
BidInputs = { }
TrickLabels = { }

SuitPickerVisible = false
SuitPickerFirstInputId = 0

RoundLabel = 0
StateLabel = 0

DealerLabel = 0
PlayerLabel = 0

TrumpLabel = 0
LeadLabel = 0

NextButton = 0

StartButton = 0
BidButton = 0

zPos = 0.6
zPosHidden = -2

--------------------------------------------
--= Game State Info
--------------------------------------------
State = State_Setup
FirstDealerSeat = 0
Round = 0
Dealer = 1
FirstPlayer = 0

--[[
    20x6 array

    dealer      - Player is dealer this round
    bid         - Player bid for this round
    score       - Player score for this round
    tricks      - Player actual tricks for this round
    didBid      - Player has bid
]]--
Scores = { }

--[[
    Array of objects:
    Color   - Player Color
    Present - Player is currently in the game
    Name    - The steam name of the player
]]--
SeatMap = { }

-- Array of objects that were dealt to players for the current round.
--[[
    Card =  Card Object,
    Owner = Id of player #,
    Color = Player oclor,
    Rank =
    Suit =
    Name =
    ]]--
DealtCards = { }

-- Array of objects that will be dropped if picked up by the player
DontTouchList = { }

--[[
    Array of objects:
    Card    = The card object
    Name    = Name of the card
    Description = Description of the card (e.g. 2 of Spades)
    Player  = Player who played the card
    Rank    = Rank of the card
    Suit    = Suit of the card
--]]
PlayedCards = { }

-- An array of strings listing the suit that was played for each round
Suits = { }

-- An array of nicknames
NickNames = { }

Trump = ""
TrumpName = ""
ResetClickTime = 0
ResetClickCount = 0

CurrentPlayerTurn = 1
Deck = nil
DicardDeck = nil
TrumpCard = nil

--------------------------------------------
--= Initialization
--------------------------------------------


--------------------------------------------
--= UI Management Functions
--------------------------------------------
function createScoreBits(xpos, ypos)
    self.createButton({
        label="", click_function="onNothing", function_owner=self,
        position={xpos, zPos, ypos}, width=0, height=0, font_size=270
    })
    self.createButton({
        label="", click_function="onNothing", function_owner=self,
        position={xpos + 1.20, zPos, ypos - 0.14}, width=0, height=0, font_size=170
    })
    self.createButton({
        label="", click_function="onNothing", function_owner=self,
        position={xpos + 1.20, zPos, ypos + 0.15}, width=0, height=0, font_size=170
    })
    self.createButton({
        label="", click_function="onNothing", function_owner=self,
        position={xpos + 0.729, zPos, ypos + 0.01}, width=0, height=0, font_size=420
    })
end

function createUI()
    local ButtonId = 0

    -- First create the name plates.
    local nameColumnsFirstX = -4.9
    local nameColumnsOffsetX = 2.258

    local scoreFirstX = -5.3
    local scoreOffX = 2.258
    local scoreFirstY = -5.6
    local scoreOffY = 0.580
    local xpos = 0
    local ypos = 0

    local suitOffX = -6.45

    local max = { 20, 20, 20, 15, 12, 10 }

    local inputsFirstX = -4.95
    local inputsOffset = 2.265
    local inputsWidth = 1090
    local inputsHeight = 270

    local statusLinesY = { 
        scoreFirstY + 15 * scoreOffY + 0.1,
        scoreFirstY + 16.5 * scoreOffY + 0.1,
        scoreFirstY + 18 * scoreOffY + 0.1,
     }

    -- Name header
    xpos = nameColumnsFirstX
    for i = 1, 6 do
        self.createButton({
            label="", click_function="onNothing", function_owner=self,
            position={xpos, zPos, -6.16}, width=0, height=0, font_size=160
        })
        NameLabels[i] = ButtonId
        ButtonId = ButtonId + 1
        xpos = xpos + nameColumnsOffsetX
    end

    -- Then create the score box.
    ypos = scoreFirstY
    for j = 1, 20 do
        xpos = scoreFirstX
        ScoreLabels[j] = { }
        local scoreLine = ScoreLabels[j]
        for i = 1, 6 do
            local actualId = -99
            if j <= max[i] then
                createScoreBits(xpos, ypos)
                actualId = ButtonId
                ButtonId = ButtonId + 4
            end
            xpos = xpos + scoreOffX

            scoreLine[i] = {
                score = actualId,
                bid = actualId + 1,
                tricks = actualId + 2,
                dealer = actualId + 3
            }
        end        
        ypos = ypos + scoreOffY
    end

    -- Create the suit column
    ypos = scoreFirstY
    for j = 1, 20 do
        self.createButton({
            label="", click_function="onNothing", function_owner=self,
            position={suitOffX, zPos, ypos}, width=0, height=0, font_size=270
        })
        ypos = ypos + scoreOffY
        SuitLabels[j] = ButtonId
        ButtonId = ButtonId + 1
    end

    -- Information Status
    self.createButton({
        label="", click_function="onNothing", function_owner=self,
        position={2.45, zPos, statusLinesY[1]}, width=0, height=0, font_size=290
    })
    RoundLabel = ButtonId
    ButtonId = ButtonId + 1

    self.createButton({
        label="", click_function="onNothing", function_owner=self,
        position={5.50, zPos, statusLinesY[1]}, width=0, height=0, font_size=270
    })
    StateLabel = ButtonId
    ButtonId = ButtonId + 1

    self.createButton({
        label="", click_function="onNothing", function_owner=self,
        position={2.45, zPos, statusLinesY[2]}, width=0, height=0, font_size=250
    })
    DealerLabel = ButtonId
    ButtonId = ButtonId + 1

    self.createButton({
        label="", click_function="onNothing", function_owner=self,
        position={ 6.15, zPos, statusLinesY[2]}, width=0, height=0, font_size=250
    })
    PlayerLabel = ButtonId
    ButtonId = ButtonId + 1

    self.createButton({
        label="", click_function="onNothing", function_owner=self,
        position={2.45, zPos, statusLinesY[3]}, width=0, height=0, font_size=250
    })
    TrumpLabel = ButtonId
    ButtonId = ButtonId + 1

    self.createButton({
        label="", click_function="onNothing", function_owner=self,
        position={ 6.15, zPos, statusLinesY[3]}, width=0, height=0, font_size=200
    })
    LeadLabel = ButtonId
    ButtonId = ButtonId + 1

    -- Bids
    local inputId = 0
    xpos = inputsFirstX
    for i = 1, 6 do
        self.createInput({input_function="onBid" .. i .. "Changed", function_owner = self, alignment=3, validation=2,
                          position = {xpos, zPos, 6.10}, width=inputsWidth, height=inputsHeight, font_size=240, label="" })
        xpos = xpos + inputsOffset
        BidInputs[i] = inputId
        inputId = inputId + 1
    end

    -- Tricks
    xpos = inputsFirstX
    for i = 1, 6 do
        self.createButton({label="", click_function="onNothing", function_owner=self,
                          position = {xpos, zPos, 6.79}, width=0, height=0, font_size=240 })
        xpos = xpos + inputsOffset
        TrickLabels[i] = ButtonId
        ButtonId = ButtonId + 1
    end

    -- Action Buttons   
    self.createButton({
        label="Next", click_function="onNextClicked", function_owner=self,
        position={-6.3, zPos, 7.8}, width=1770, height=450, font_size=400
    })
    NextButton = ButtonId
    ButtonId = ButtonId + 1

    self.createButton({
        label="Reset", click_function="onReset", function_owner=self,
        position={6.5, zPos, 7.8}, width=1470, height=450, font_size=400,
        tooltip="Double click to reset."
    })
    ButtonId = ButtonId + 1
end

-- Suit Picker

function showSuitPicker()
    if (SuitPickerVisible) then return end
    SuitPickerVisible = true

    local buttons = self.getButtons()
    SuitPickerFirstInputId = #buttons 

    local inputsFirstX = -5.25
    local inputsOffset = 3.685
    local inputsWidth = 1800
    local inputsHeight = 500

    xpos = inputsFirstX
    self.createButton({click_function="onPickHearts", function_owner = self, alignment=3, validation=2,
    position = {xpos, zPos, -7.50}, width=inputsWidth, height=inputsHeight, font_size=350, label="Hearts" })
    xpos = xpos + inputsOffset
    
    self.createButton({click_function="onPickClubs", function_owner = self, alignment=3, validation=2,
    position = {xpos, zPos, -7.50}, width=inputsWidth, height=inputsHeight, font_size=350, label="Clubs" })
    xpos = xpos + inputsOffset
    
    self.createButton({click_function="onPickDiamonds", function_owner = self, alignment=3, validation=2,
    position = {xpos, zPos, -7.50}, width=inputsWidth, height=inputsHeight, font_size=350, label="Diamonds" })
    xpos = xpos + inputsOffset
    
    self.createButton({click_function="onPickSpades", function_owner = self, alignment=3, validation=2,
    position = {xpos, zPos, -7.50}, width=inputsWidth, height=inputsHeight, font_size=350, label="Spades" })

end

function hideSuitPicker()
    if (not SuitPickerVisible) then return end

    for i = 1, 4 do
        self.removeButton(SuitPickerFirstInputId + i - 1)
    end

    SuitPickerVisible = false
end
--------------------------------------------
--= Tabletop Simulator Event Handlers
--------------------------------------------

function onChat(message, player)
    if (string.sub(message, 1, 1) != '!') then
        return
    end

    commandHandler(player, string.sub(message, 2))
end

-- TODO: Implement onSave

function onLoad(save_state)
    createUI()
    resetGame()
    refreshSeatMap()
    updateAll()
end

function onPlayerChangeColor(player_color)
    refreshSeatMap()
end

function onPlayerConnect(player_id)
    refreshSeatMap()
end

function onPlayerDisconnect(player_id)
    refreshSeatMap()
end

function onPlayerTurnStart(player_color_start, player_color_previous)    
    ensureCorrectTurn(player_color_previous, player_color_start)
end

function onPlayerTurnEnd(player_color_end, player_color_next)
    ensureCorrectTurn(player_color_end, player_color_next)
end

function onObjectDestroy(dying_object)
    if (dyingObject == Deck) then Deck = nil end
end

function onObjectSearchStart(object, player_color)
    local player = getPlayerNumberFromColor(player_color)
    broadcastToAll(SeatMap[player].Name .. " is examining the draw pile! Cheater!", TABLE_text_color)
end

-- Need to capture when a container gets created...
function onObjectEnterContainer(container, enter_object)
    if (Recalling) then
        CreatedDeck = container
        return
    end
    if (Discarding) then
        CreatedDiscardDeck = container
        return
    end
end

CardOverScriptingZone = nil

function onObjectEnterScriptingZone(zone, enter_object)
    if (zone.getGUID() != PlayAreaScriptingZone) then return end
    if (enter_object.tag != 'Card') then return end
    CardOverScriptingZone = enter_object
end

function onObjectLeaveScriptingZone(zone, leave_object)
    if (zone.getGUID() != PlayAreaScriptingZone) then return end
    if (leave_object.tag != 'Card') then return end
    CardOverScriptingZone = nil
end

function onObjectPickUp(player_color, picked_up_object)
    if Discarding or Recalling then 
        picked_up_object.drop()
        broadcastToColor("Leave it!", player_color)
    end

    if DontTouchList == nil then return end
    for i = 1, #DontTouchList do 
        if picked_up_object == DontTouchList[i] then
            picked_up_object.drop()
            broadcastToColor("Leave it!", player_color)
        end
    end

    local number = getPlayerNumberFromColor(player_color)
    
    for i = 1, #DealtCards do
        if DealtCards[i].Owner != number and DealtCards[i].Card == picked_up_object then
            picked_up_object.drop()
            broadcastToColor("You can only play cards that were dealt to you!", player_color)
        end
    end
end

function onObjectDrop(player_color, dropped_object)
    cardName = dropped_object.getName()
    cardDesc = dropped_object.getDescription()

    if (State == State_Setup or State == State_Done) then return end

    -- If a card was moved out of the play area, move it back.
    if (PlayedCards != nil) then
        for i = 1, #PlayedCards do
            if PlayedCards[i].Name == cardName then
                local home = getObjectFromGUID(PlayAreaScriptingZone)
                local homeBounds = home.getBounds()
                local homePos = 
                {
                    homeBounds.center.x + math.random() * 30 - 15,
                    homeBounds.center.y,
                    homeBounds.center.z + math.random() * 20 - 12.5,
                }
            
                broadcastToColor("Hey! Put that back!", player_color)
                dropped_object.setPositionSmooth(homePos, false, false)
                return
            end
        end
    end

    -- If the card wasn't dealt to the player move it off the 
    -- board. 
    if (DealtCards != nil) then
        local found = false
        for i = 1, #DealtCards do
            if cardName == DealtCards[i].Name then
                found = true
            end
        end

        if not found then
            broadcastToColor("Hey! That doesn't belong here!", player_color)
            dropped_object.setPositionSmooth(BadPlayPosition, false, false)
            return
        end
    end
    
    if (CardOverScriptingZone == nil) then 
        dropped_object.deal(1, player_color)
        return
    end

    CardOverScriptingZone = nil

    local player = getPlayerNumberFromColor(player_color)

    if (player == 0) then
        print("Player is 0 -- that's bad.")
        return
    end

    if (validateCard(cardName, player)) then
        cardDesc = dropped_object.getDescription()
        broadcastToAll(SeatMap[CurrentPlayerTurn].Name .. " played the " .. cardDesc)
        csuit, crank = cardNameToSuitRank(cardName)

        PlayedCards[#PlayedCards + 1] = 
        {
            Card = dropped_object,
            Name = cardName,
            Description = cardDesc,
            Player = player,
            Rank = crank,
            Suit = csuit
        }

        checkHand()
        updateRound()
    else
        dropped_object.deal(1, player_color)
    end
end

--------------------------------------------
--= Game Logic
--------------------------------------------
function beginNextRound()
    Round = Round + 1
   
    if (Round > MaxRounds[#SeatMap]) then 
        local Winners = {}
        local Score = 0
        local FinalScores = Scores[MaxRounds[#SeatMap]]

        for i = 1, #SeatMap do
            if FinalScores[i].score > Score then
                Score = FinalScores[i].score
                Winners = {}
                Winners[1] = SeatMap[i].Name
            elseif FinalScores[i].score == Score then
                Winners[#Winners+1] = SeatMap[i].Name
            end
        end

        if #Winners == 1 then
            broadcastToAll("Game over! " .. Winners[1] .. " won!")
        else
            broadcastToAll("Game over! " .. table.concat(Winners, " and ") .. " tied!")
        end

        State = State_Done
        return
    end

    broadcastToAll("==== Starting hand " .. Round .. " ====")
    State = State_Bid
    recallPack()
    dealCardsLater()

    -- Figure out who deals next
    Dealer = (((FirstDealerSeat - 1) + (Round - 1)) % (#SeatMap)) + 1
    FirstPlayer = modValue(Dealer + 1, #SeatMap)
    CurrentPlayerTurn = FirstPlayer

    setTurnToCurrentPlayer()

    Scores[Round] = { }
    local scoreRow = Scores[Round]
    for i = 1, #SeatMap do
        scoreRow[i] = {
            dealer = (i == Dealer),
            bid = 0,
            score = 0,
            tricks = 0,
            didBid = false,
        }
    end

    clearFields()
    updateAll()
end

function onNextClicked()
    if State == State_Setup then 
        FirstDealerSeat = Dealer
        Round = 0
        Scores = { }
        beginNextRound()
        enableTurns()
    elseif State == State_Bid then
        onBidClicked()
    elseif State == State_Play then
        broadcastToAll("Please don't press this button again.")
    elseif State == State_Done then
        broadcastToAll("The game is over. Press reset to start over.")
        disableTurns()
    elseif State == State_PickSuit then
        broadcastToAll(SeatMap[Dealer].Name .. ", please pick a suit from the menu at the top of the score card.")
    end

    updateAll()
end

function onBidClicked()
    local scoreRow = Scores[Round]
    local needToBid = { }
    for i = 1, #SeatMap do
        if (scoreRow[i].didBid == false) then
            needToBid[#needToBid + 1] = SeatMap[i].Name
        end

        if (scoreRow[i].bid > Round) then
            scoreRow[i].bid = Round
        end
    end

    if #needToBid > 0 then
        local s = "The following player(s) still need to bid: " .. table.concat(needToBid, ", ")
        broadcastToAll(s)
        return
    end

    broadcastToAll(SeatMap[CurrentPlayerTurn].Name .. " plays first this hand.")

    State = State_Play
end

function onRoundOver()
    local scoreRow = Scores[Round]
    PlayedCards = { }

    lastScores = {0, 0, 0, 0, 0, 0}
    if (Round > 1) then
        local oldScoreRow = Scores[Round - 1]
        for i = 1, #SeatMap do
            lastScores[i] = oldScoreRow[i].score
            if lastScores[i] == nil then
                lastScores[i] = 0
            end
        end
    end

    for i = 1, #SeatMap do
        local score = 0
        if (scoreRow[i].bid - scoreRow[i].tricks == 0) then
            score = 2 + scoreRow[i].tricks
        else
            score = -math.abs(scoreRow[i].bid - scoreRow[i].tricks)
        end

        scoreRow[i].score = lastScores[i] + score
    end

    beginNextRound()
end

function onReset(obj, player_clicker_color, alt_click)

    if (State != State_Done) then
        local now = os.clock()
        local diff = now - ResetClickTime

        ResetClickTime = now
        if (diff > 0.5) then return end
    end

    local player = getPlayerNumberFromColor(player_clicker_color)
    if player > 0 then 
        broadcastToAll(SeatMap[player].Name .. " is resetting the game!")
    end

    resetGame()
end

function onPrevDealer()
    if State != State_Setup then
        return
    end

    Dealer = Dealer - 1
    if (Dealer < 1) then
        local seated = getSeatedPlayers()
        Dealer = #seated
    end

    updateAll()
end

function onNextDealer()
    if State != State_Setup then
        return
    end

    local seated = getSeatedPlayers()
    Dealer = Dealer + 1
    if (Dealer > #seated) then
        Dealer = 1
    end

    updateAll()
end

function currentRound()
end

function nextRound()
end

function refreshSeatMap()
    local seated = getSeatedPlayers()
    local total = #seated
    if (total > 6) then total = 6 end
    if (seated == nil) then SeatMap = { } return end

    if State == State_Setup then
        SeatMap = {}
        for c = 1, #SeatOrder do
            for i = 1, #seated do
                if seated[i] == SeatOrder[c] then
                    local altName = NickNames[seated[i]]
    
                    SeatMap[#SeatMap+1] = {
                        Color = seated[i],
                        Name = altName or Player[seated[i]].steam_name,
                        Present = true
                    }
                end
            end
        end

        if (Dealer < 1 or Dealer > #seated) then
            Dealer = #seated
        end
    else
        for i = 1, #SeatMap do
            SeatMap[i].Present = false
            SeatMap[i].Name = "???"
        end
        for i = 1, #seated do
            for j = 1, #SeatMap do
                if SeatMap[j].Color == seated[i] then
                    SeatMap[j].Present = true
                    SeatMap[j].Name = Player[seated[i]].steam_name 
                end
            end
        end
    end

    updateAll()
end

function updateAll()
    updateScores()
    updateRound()
    updateTricks()
    updateSuits()
    updatePlayers()
end

function getCurrentBidder()
    if (State == State_Done) then return 0 end
    if (Round == 0) then return 0 end

    local scoreRow = Scores[Round]
    for i = 1, #SeatMap do
        local pos = modValue(Dealer + i, #SeatMap)
        if (not scoreRow[pos].didBid) then
            return pos
        end
    end

    return 0
end

function getCurrentBidderName()
    local pos = getCurrentBidder()
    if pos != 0 then
        return SeatMap[pos].Name
    end
    return ""
end

function highlightCurrentBidder()
    pos = getCurrentBidder()

    for i = 1, 6 do
        if pos == i then
            self.editInput({index = BidInputs[i], color = {1,1,0.8,1}})
        else
            self.editInput({index = BidInputs[i], color = {1,1,1,1}})
        end
    end
end

function updateRound()
    local round = ""
    local state = ""
    local dealer = ""
    local player = ""
    local trump = ""
    local lead = ""

    if State == State_Setup then        
        state = "Game Setup"
        dealer = SeatMap[Dealer].Name
        self.editButton({index = NextButton, label = "Start", tooltip="Press this button to start the game."})
    elseif State == State_Done then
        state = "Game Over"
        self.editButton({index = NextButton, label = "Press Reset", tooltip="Don't press here, press the reset button."})
    else
        round = Round
        dealer = SeatMap[Dealer].Name
        player = SeatMap[CurrentPlayerTurn].Name
        trump = TrumpName

        -- Determins what the lead card field should show
        -- If a Jester was played first, jester is the lead until
        -- a new 'trump' is played. At which point we will show the new
        -- leader plus (J).
        if PlayedCards then
            local temp = nil
            for i = 1, #PlayedCards do
                if temp == nil or temp == 'J' then
                    if temp == "J" and PlayedCards[i].Suit != "J" then
                        lead = PlayedCards[i].Description .. "(J)"
                    else
                        lead = PlayedCards[i].Description
                    end

                    temp = PlayedCards[i].Suit
                end
            end            
        end

        if State == State_Bid then
            state = "Bidding"
            player = getCurrentBidderName()
            self.editButton({index = NextButton, label = "Confirm", tooltip="Lock in everyone's bids."})
        elseif State == State_Play then
            state = "Playing Hand"
            self.editButton({index = NextButton, label = "", tooltip="Please don't press this button right now."})
        elseif State == State_PickSuit then
            player = SeatMap[Dealer].Name
            state = "Picking Suit"
            self.editButton({index = NextButton, label = "Pick Suit", tooltip="Click a button at the top of the score sheet to select the suit."})
        end
    end

    self.editButton({index = RoundLabel, label = round})
    self.editButton({index = StateLabel, label = state})
    self.editButton({index = DealerLabel, label = dealer})
    self.editButton({index = PlayerLabel, label = player})
    self.editButton({index = TrumpLabel, label = trump})
    self.editButton({index = LeadLabel, label = lead})

    highlightCurrentBidder()
end

function updateScores()
    for i = 1, #Scores do
        local scoreLine = Scores[i]
        local labels = ScoreLabels[i]

        for j = 1, #SeatMap do
            if labels[j].bid > 0 then
                dealer = ""
                if scoreLine[j].dealer then
                    dealer = "."
                end
                local score = ""
                local tricks = ""
                local bid = ""
                if (Round > i) then 
                    score = scoreLine[j].score 
                    tricks = scoreLine[j].tricks
                    bid = scoreLine[j].bid
                elseif State > State_Bid then
                    bid = scoreLine[j].bid
                end

                self.editButton({index = labels[j].score, label = score})
                self.editButton({index = labels[j].bid, label = bid})
                self.editButton({index = labels[j].tricks, label = tricks})
                self.editButton({index = labels[j].dealer, label = dealer})
            end
        end
        for j = #SeatMap + 1, 6 do
            if labels[j].bid > 0 then
                self.editButton({index = labels[j].score, label = ""})
                self.editButton({index = labels[j].bid, label = ""})
                self.editButton({index = labels[j].tricks, label = ""})
                self.editButton({index = labels[j].dealer, label = ""})
            end
        end
    end

    for i = #Scores + 1, 20 do
        local labels = ScoreLabels[i]

        for j = 1, 6 do
            if labels[j].bid > 0 then
                self.editButton({index = labels[j].score, label = ""})
                self.editButton({index = labels[j].bid, label = ""})
                self.editButton({index = labels[j].tricks, label = ""})
                self.editButton({index = labels[j].dealer, label = ""})
            end
        end
    end
end

function updateTricks()
    local scoreLine = Scores[Round]
    for i = 1, 6 do 
        local trickCount = ""
        if scoreLine != nil and State > State_Bid then 
            local score = scoreLine[i]
            if score != nil then
                trickCount = score.tricks
                if trickCount == nil then
                    trickCount = ""
                end
            end
        end

        self.editButton({index = TrickLabels[i], label = trickCount})
    end
end

function updatePlayers()
    for i = 1, #SeatMap do
        self.editButton({index = NameLabels[i], label = SeatMap[i].Name})
    end

    if (#SeatMap < 6) then
        for i = #SeatMap + 1, #NameLabels do
            self.editButton({index = NameLabels[i], label = ""})
        end
    end
end

function updateSuits()
    for i = 1, #Suits do
        self.editButton({index = SuitLabels[i], label = Suits[i]})
    end

    for i = #Suits + 1, 20 do
        self.editButton({index = SuitLabels[i], label = ""})
    end
end

function disableTurns()
    Turns.enable = false
    Turns.type = 2
    Turns.disable_interactations = false
end

function enableTurns()
    Turns.enable = true
    Turns.disable_interactations = true
    Turns.type = 2
    Turns.pass_turns = false
    Turns.skip_empty_hands = false

    local turnOrder = { }
    for i = 1, #SeatMap do
        turnOrder[i] = SeatMap[i].Color
    end

    Turns.order = turnOrder
end

function ensureCorrectTurn(player_color_prev, player_color_next)
    -- At the beginning there's nothing in the seat map so there's
    -- no need to check the current turn.
    if (#SeatMap == 0) then return end

    local currentColor = SeatMap[CurrentPlayerTurn].Color

    if (player_color_next != currentColor) then
        setTurnToCurrentPlayer()
    end
end

function resetGame()
    disableTurns()

    State = State_Setup
    FirstDealerSeat = 0
    Round = 0
    Dealer = 1
    Scores = { }
    SeatMap = { }
    Suits = { }
    Trump = ""
    TrumpName = ""
    PlayedCards = { }
    recallPack()
    refreshSeatMap()
    updateAll()
end

function resetRound()
    -- Can't reset the round if we aren't in a game.
    if State == State_Setup or State == State_Done then
        printToAll("The round cannot be reset right now. Please start a game.")
        return
    end

    -- Pretend it is the beginning of a new round
    Round = Round - 1
    PlayedCards = { }
    beginNextRound()
end

Timers = 0
function setInputValueLater(index, text)
    Timers = Timers + 1
    Timer.create({
        identifier = "Timer" .. Timers,
        function_name = "onSetInputExpired",
        parameters = { index = index, text = text },
        delay = 0,
        repetitions = 1
    })
end

function onSetInputExpired(params)
    self.editInput({index = params.index, value = params.text})
end

function dealCardsLater()
    startLuaCoroutine(self, "onDealCardsCoroutine")
end

function onDealCardsCoroutine(params)
    for i = 1, 120 do
        coroutine.yield(0)
    end

    -- Reset some things to a clean state.
    DealtCards = { }
    DontTouchList = { }
    Deck.shuffle()

    for i = 1, 180 do
        coroutine.yield(0)
    end

    -- Get a list of the objects in the deck for use later.
    local deckObjects = Deck.getObjects()

    -- Set up the hands for each of the players.
    local hands = {}
    for i = 1, #SeatMap do
        local hand = {}

        -- Figure out which cards would be dealt to the player
        -- by name.
        for j = 1, Round do
            hand[j] = deckObjects[(i) + (j-1) * #SeatMap].name
        end

        -- Sort the cards to make it easier for the player.
        table.sort(hand, function(left, right)
            suitL, rankL = cardNameToSuitRank(left)
            suitR, rankR = cardNameToSuitRank(right)
    
            if suitL == suitR then
                 return rankL > rankR 
            else
                 return suitToValue(suitL) > suitToValue(suitR)
            end
        end)

        hands[i] = hand
    end

    -- Actually hand out the cards to each of the players.
    for r = 1, Round do
        for i = 1, #SeatMap do
            -- Find the card we are going to be dealing out.
            local name = hands[i][r]
            local obj = findCard(name)
            local c = obj.Card

            if obj.InDeck != nil then 
                -- Pull it out of the deck from wherever it is.
                c = obj.InDeck.takeObject({ guid = obj.Card.guid })
            end

            -- Wait til the card is pulled, also makes for a more
            -- satisfying animation.
            for i=1,20 do
                coroutine.yield(0)
            end

            -- Give the card to the player.
            c.Deal(1, SeatMap[i].Color)
    
            -- Hang onto all of the information about the card that's been dealt out.
            DealtCards[#DealtCards+1] = {
                Card = c,
                Owner = i,
                Color = SeatMap[i].Color,
                Rank = string.sub(name, 1, 1),
                Suit = string.sub(name, 2, 2),
                Name = name
            }
        end
    end

    -- If this isn't the last round, then pick a trump
    if Round < MaxRounds[#SeatMap] then
        TrumpCard = Deck.takeObject({top = true})
        DontTouchList[1] = TrumpCard
        TrumpCard.flip()
        Trump = string.sub(TrumpCard.getName(), 2, 2)
    else
        -- Last round, that's no trump.
        Trump = 'J'
        TrumpName = "No Trump"
        TrumpCard = nil
    end

    if (Trump == "H") then
        TrumpName = "Hearts"
        Suits[Round] = 'H'
    elseif (Trump == "C") then
        TrumpName = "Clubs"
        Suits[Round] = 'C'
    elseif (Trump == "S") then
        TrumpName = "Spades"
        Suits[Round] = 'S'
    elseif (Trump == "D") then
        TrumpName = "Diamonds"
        Suits[Round] = 'D'
    elseif (Trump == "J") then
        TrumpName = "No Trump"
        Suits[Round] = 'N'
    elseif (Trump == "W") then
        TrumpName = "Wizard"
        Suits[Round] = '*'
        State = State_PickSuit
        broadcastToAll("Turned a Wizard as trump!")
        broadcastToAll(SeatMap[Dealer].Name .. " please pick the trump suit from the top of the score sheet!")
        showSuitPicker()
        onNextClicked()
    end

    if (Trump != "W") then 
        if (Trump == "J") then
            if (Round < MaxRounds[#SeatMap]) then
                broadcastToAll("No trump this hand!")
            else
                broadcastToAll("Final hand, no trump!")
            end
        else
            broadcastToAll(TrumpName .. " is trump for this hand.")
        end
        broadcastToAll(SeatMap[FirstPlayer].Name .. " bids first.")
    end

    updateAll()
    return 1
end

function onBidChanged(index, player_clicker_color, input_value, selected)
    local scoreRow = Scores[Round]

    if (index > #SeatMap) then
        if input_value == nil or input_value == "" then return end
        setInputValueLater(BidInputs[index], "")
        broadcastToColor("That player is not playing.", player_clicker_color)
        return
    end

    if (Round < 1 or State < State_Bid) then
        if input_value == nil or input_value == "" then return end
        setInputValueLater(BidInputs[index], "")
        broadcastToColor("It is not time to bid yet.", player_clicker_color)
        return
    end

    if (State > State_Bid) then
        setInputValueLater(BidInputs[index], scoreRow[index].bid)
        broadcastToColor("You can't change your bid now.", player_clicker_color)
        return
    end

    firstIndex = modValue(Dealer + 1, #SeatMap)

    if index != firstIndex then
        checkSeat = index - 1
        if checkSeat < 1 then checkSeat = #SeatMap end
        if not scoreRow[checkSeat].didBid then
            if input_value == nil or input_value == "" then return end
            setInputValueLater(BidInputs[index], "")
            broadcastToColor("Please wait until " .. SeatMap[checkSeat].Name .. " has bid.", player_clicker_color)
            return
        end
    end
   
    local bid = tonumber(input_value)
    if (bid == nil) then return end
    if bid < 0 then bid = 0 end
    if bid > Round then bid = Round end
    
    scoreRow[index].bid = bid
    scoreRow[index].didBid = not (input_value == nil or input_value == '')

    if not selected then
        setInputValueLater(BidInputs[index], bid)
    end

    updateRound()
end

CreatedDeck = nil
CreatedDiscardDeck = nil

function addToDeck(card)
    if (Deck == nil) then
        CaptureEnterContainer = true
        Deck = card
    else
        Deck.putObject(card)
        Deck = CreatedDeck
    end
end

function addToDiscardDeck(card)
    return pcall(function()
        card.setLock(false)

        DontTouchList[#DontTouchList+1] = card
        
        if not card.is_face_down then
            card.flip()
        end
        
        card.drop()
        
        card.setPositionSmooth(DiscardDeckPosition, false, false)
    end)
end

function clearFields()
    for i = 1, 6 do
        self.editInput({index = BidInputs[i], value = ""})
    end
end

Recalling = false
Discarding = false

function unlockDeck()
    Deck.setLock(false)
end

function makePlayerDropCards()
    playerList = Player.getPlayers()
    for _, playerReference in ipairs(playerList) do
        local souls = playerReference.getHoldingObjects()
        if souls != nil then
            for i = 1, #souls do
                souls[i].drop()
            end
        end
    end
end

function recallPack()
    local souls = getAllObjects()
    local deck = nil

    makePlayerDropCards()	

    status, result = pcall(unlockDeck)

    if (DiscardDeck != nil) then DiscardDeck.setLock(false) end

    DiscardDeck = nil
    Deck = nil
    Recalling = true

    for i,soul in ipairs(souls) do
        -- For some reason "soul.name" only returns the object name
        -- even if it has a nickname on it, so my solution was this:
        local soulName = tostring(soul.getName())
        local soulTag = soul.tag
        local soulGuid = soul.getGUID()

        if (soulTag == 'Card') then
            soul.setLock(false)
            addToDeck(getObjectFromGUID(soulGuid))
        elseif soulTag == 'Deck' then
            soul.setLock(false)
            addToDeck(soul)
        end
    end

    if not Deck.is_face_down then 
        Deck.flip()
    end

    Recalling = false
    Deck.setPosition(DeckPosition, false, true)
    Deck.setLock(true)
end


function collectDiscards()
    -- pick up the cards on the mat
    for i = 1, #Discards do
        -- If the player is holding a card over a card that's being collected
        -- it can't be collected. And everything breaks.
        local cardResult = findCard(Discards[i].Name)
        local card = cardResult.Card
        if (cardResult.InDeck) then
            if not pcall(function()
                card = cardResult.InDeck.takeObject({ guid = card.Card.guid })
            end) then
                if not pcall(function()
                    card = cardResult.InDeck.takeObject({ guid = card.Card.getGuid() })
                end) then
                    print("This is emabarassing...")
                end
            end
        end

        print("Discarding " .. Discards[i].Name)

        if not addToDiscardDeck(card) then
            print("Can't clean up " .. Discards[i].Name)
            print("You might be able to finish the hand")
        end
    end
end

function finishCheckHandLater()
    startLuaCoroutine(self, "onFinishCheckHand")
end

Winner = {}
Discards = {}

function onFinishCheckHand()
    -- Wait a little bit before cleaning everything up. We should
    -- replace this with a timer instead. Then we won't need the 
    -- Winner global variable.
    for i = 0,60*5 do
        coroutine.yield(0)

        -- If the player tries to fuck around, things go sour.
        -- So this will prevent that hopefully.
        makePlayerDropCards()
    end

    -- Cards left for the round?
    local scoreLine = Scores[Round]
    local tricksTaken = 0
    for i = 1, #scoreLine do
        tricksTaken = tricksTaken + scoreLine[i].tricks
    end

    if tricksTaken >= Round then
        onRoundOver()
    else
        CurrentPlayerTurn = Winner.Player

        collectDiscards()

        Discards = { }
        Winner = { }

        setTurnToCurrentPlayer()
    end

    updateAll()

    return 1
end

function checkHand()
    if (#PlayedCards == #SeatMap) then
        -- Round is over

        -- Determine the winner. Assume the first card is rock, and is currently
        -- winning.
        Winner = PlayedCards[1]
        for i = 2, #PlayedCards do
            -- If the current winner isn't a wizard, then something could
            -- potentially trump it.
            if Winner.Suit != 'W' then
                local theCard = PlayedCards[i]
                if theCard.Suit == 'J' then
                    -- It's not a winner for sure.
                elseif theCard.Suit == 'W' then
                    -- The wizard is the winner for sure
                    Winner = theCard
                else
                    if Winner.Suit == 'J' then
                        -- The current winner is a Jester and anything is better.
                        Winner = theCard
                    elseif theCard.Suit == Winner.Suit then
                        -- If the cards are the same suit then a card of a higher
                        -- rank becomes the winner.
                        if theCard.Rank > Winner.Rank then
                            Winner = theCard
                        end
                    elseif theCard.Suit == Trump then
                        -- If the cards aren't the same suit, then if the card is
                        -- trump then it is the winner regardless of rank.
                        Winner = theCard
                    end
                end
            end    
        end

        broadcastToAll(SeatMap[Winner.Player].Name .. " won the trick with the " .. Winner.Description)

        -- Increment the player's tricks
        local scoreLine = Scores[Round]
        scoreLine[Winner.Player].tricks = scoreLine[Winner.Player].tricks + 1

        updateAll()
        finishCheckHandLater()
        Discards = PlayedCards
        PlayedCards = { }
    else
        -- Next player needs to play
        CurrentPlayerTurn = modValue(CurrentPlayerTurn + 1, #SeatMap)
        setTurnToCurrentPlayer()
    end
end

function validateCard(cardName, player)
    if Winner == {} or Winner == nil then
        broadcastToAll("Still cleaning up the last hand... hang on.")
        return false
    end

    if #PlayedCards >= #SeatMap then
        broadcastToAll("Still cleaning up the last hand... hang on.")
        return false
    end

    -- Don't let the player play out of turn.
    if player != CurrentPlayerTurn then
        broadcastToAll("It's still " .. SeatMap[CurrentPlayerTurn].Name .. "'s turn!")
        return false
    end

    -- Don't let the player play cards before the bidding has been completed
    if State != State_Play then
        broadcastToAll("Please bid first!")
        return false
    end

    -- Assuming the player is allowed to play _ANY_ card should be fine...
    -- Although maybe this should check to see if the card that they do
    -- play actually came from their hand....
    if #PlayedCards == 0 then
        return true
    end

    -- Just a check to see if the player has already played a card. Since 
    -- it's not possible to set the turn to nobody, we have to make sure
    -- that the player can't just keep dropping cards or the script will
    -- get broken.
    for i = 1, #PlayedCards do
        if (PlayedCards[i].Player == player) then
            broadcastToAll("Hold yer horses. You've already played!")
            return false
        end
    end

    suit, rank = cardNameToSuitRank(cardName)

    -- The player can always play a Wizard or Jester no matter
    -- what else is played.
    if (suit == 'W' or suit == 'J') then
        return true
    end

    -- Determine the current suit for the hand.
    currentSuit = nil
    for i = 1, #PlayedCards do 
        if currentSuit == nil then
            if PlayedCards[i].Suit == 'W' then
                currentSuit = 'W'
            elseif PlayedCards[i].Suit == 'J' then
                -- Skip jesters
            else
                currentSuit = PlayedCards[i].Suit
            end
        end               
    end

    -- If a wizard is the current suit or the current suit
    -- hasn't been determined yet (e.g. only Jesters have
    -- been played) then any card is valid.
    if currentSuit == 'W' or currentSuit == nil then
        return true
    end

    -- Can always play a card in suit.
    if currentSuit == suit then
        return true
    end

    -- Otherwise the player is playing out of suit...

    -- Determine what cards are in the player's hand.
    local handObjects = Player[SeatMap[player].Color].GetHandObjects(1)
    local hand = {}
    for i,o in ipairs(handObjects) do
        hand[i] = {
            Rank = string.sub(o.getName(), 1, 1),
            Suit = string.sub(o.getName(), 2, 2)
        }
    end

    -- If they're playing out of suit, then we need to see if they're
    -- cheating or not.
    for i = 1, #hand do
        if (currentSuit == hand[i].Suit) then
            broadcastToAll("You can't play that card since you still have other valid plays...")
            return false
        end
    end

    -- If they can't play in suit, then any card they have played is fine.
    return true
end

function onPickSuit(suit, suitName, playerColor)
    if (State != State_PickSuit) then
        broadcastToAll("Sorry it's not time to pick a suit.")
    end

    if (SeatMap[Dealer].Color != playerColor) then
        broadcastToColor("Sorry only " .. SeatMap[Dealer].Name .. ", the dealer, is allowed to pick the trump suit.", playerColor)
        return
    end

    Suits[Round] = suit .. "*"
    Trump = suit
    TrumpName = suitName
    State = State_Bid

    broadcastToAll(SeatMap[Dealer].Name .. " selected " .. TrumpName .. " as trump for the hand.")
    broadcastToAll(SeatMap[FirstPlayer].Name .. " bids first.")

    hideSuitPicker()
    updateAll()
end

function onPickHearts(obj, player_clicker_color, alt_click)
    onPickSuit("H", "Hearts", player_clicker_color)
end

function onPickClubs(obj, player_clicker_color, alt_click)
    onPickSuit("C", "Clubs", player_clicker_color)
end

function onPickDiamonds(obj, player_clicker_color, alt_click)
    onPickSuit("D", "Diamonds", player_clicker_color)
end

function onPickSpades(obj, player_clicker_color, alt_click)
    onPickSuit("S", "Spades", player_clicker_color)
end

-- Fuck this bullshit.
function onBid1Changed(obj, player_clicker_color, input_value, selected)
    onBidChanged(1, player_clicker_color, input_value, selected)
end
function onBid2Changed(obj, player_clicker_color, input_value, selected)
    onBidChanged(2, player_clicker_color, input_value, selected)
end
function onBid3Changed(obj, player_clicker_color, input_value, selected)
    onBidChanged(3, player_clicker_color, input_value, selected)
end
function onBid4Changed(obj, player_clicker_color, input_value, selected)
    onBidChanged(4, player_clicker_color, input_value, selected)
end
function onBid5Changed(obj, player_clicker_color, input_value, selected)
    onBidChanged(5, player_clicker_color, input_value, selected)
end
function onBid6Changed(obj, player_clicker_color, input_value, selected)
    onBidChanged(6, player_clicker_color, input_value, selected)
end

--------------------------------------------
--= Console Handlers
--------------------------------------------
function commandHandler(player, commandLine)
    local parts = split(commandLine, " ")
    local command = string.lower(parts[1])
    if (command == "help") then
        onCommandHelp()
    elseif (command == "reset") then
        if (#parts != 2) then
            printToAll("reset needs an argument")            
        else
            onCommandReset(string.lower(parts[2]))
        end
    elseif (command == "start") then
        onCommandStart()
    elseif (command == "becomedealer") then
        onCommandBecomeDealer(player.color)
    elseif (command == "setdealer") then
        if (#parts != 2) then
            printToAll("becomedealer needs an argument")            
        else
            onCommandSetDealer(parts[2])
        end
    elseif (command == "randomdealer") then
        onCommandRandomDealer()
    elseif (command == "nick") then
        if (#parts != 2) then
            printToAll("nick needs an argument")            
        else
            onCommandSetNick(player.color, parts[2])
        end
    else
        printToAll("Unknown command: '" .. command .. "'. Type !help for help.")
    end
end

function onCommandHelp()
    printToAll("Wizard Help")
    printToAll("-----------")
    printToAll("All commands are prefixed with an !")
    printToAll("!help - Show this help text.")
    printToAll("!reset [game|round] - Reset the game or redeal the round.")
    printToAll("")
    printToAll("Commands available before the game has started")
    printToAll("!start - Start the game if it hasn't been started")
    printToAll("!becomeDealer - Makes your player become the dealer")
    printToAll("!setDealer [number] - Sets a specific player as dealer")
    printToAll("!randomDealer - Random dealer")
    printToAll("!nick [name] - Sets your display name ")
end

function onCommandReset(argument)
    if (argument == "game") then
        resetGame()
    elseif (argument == "round") then
        resetRound()
    else
        printToAll("!reset invalid argument")
    end
end

function onCommandStart()
    if State == State_Setup then 
        onNextClicked()
    else
        printToAll("!start requires the game to be in a reset state")
    end
end

function onCommandBecomeDealer(playerColor)
    if State != State_Setup then 
        printToAll("Can't change the dealer after the game has started")
    end

    for i = 1, #SeatMap do
        if SeatMap[i].Color == playerColor then
            Dealer = i
        end
    end

    updateAll()
end

function onCommandSetDealer(playerNumber)
    if State != State_Setup then 
        printToAll("Can't change the dealer after the game has started")
    end

    local num = tonumber(playerNumber)
    if (num >= 1 and num <= #SeatMap) then
        Dealer = num
    else
        printToAll("That player doesn't exist")
    end

    updateAll()
end

function onCommandRandomDealer()
    if State != State_Setup then 
        printToAll("Can't change the dealer after the game has started")
    end

    Dealer = math.random(#SeatMap)
    print ("Dealer is " .. Dealer)
    updateAll()
end

function onCommandSetNick(player, newName)
    if State != State_Setup then 
        printToAll("Can't change the nickname after the game has started")
    end

    NickNames[player] = newName
    refreshSeatMap()
end

--------------------------------------------
--= Utility Functions
--------------------------------------------
function split(str)
    local tbl = {}
    for i in string.gmatch(str, "%S+") do
        tbl[#tbl+1] = i
    end
    return tbl
end
 
function setTurnToCurrentPlayer()
    startLuaCoroutine(self, "setTurnToCurrentPlayerCoroutine")
end

function setTurnToCurrentPlayerCoroutine()
    coroutine.yield(0)

    if Turns.turn_color != SeatMap[CurrentPlayerTurn].Color then
        Turns.turn_color = SeatMap[CurrentPlayerTurn].Color
    end

    return 1
end

function getPlayerNumberFromColor(player_color)
    for i,seat in ipairs(SeatMap) do
        if seat.Color == player_color then
            return i
        end
    end

    return 0
end

function cardNameToSuitRank(name)
    if #name != 2 then return nil, nil end

    local rank = string.sub(name, 1, 1)
    local suit = string.sub(name, 2, 2)

    if (suit != "H" and suit != "C" and suit != "D" and suit != "S" and suit != "J" and suit != "W") then return nil, nil end

    nrank = nil
    if rank == 'K' then nrank = 13
    elseif rank == 'Q' then nrank = 12
    elseif rank == 'J' then nrank = 11
    elseif rank == 'T' then nrank = 10
    elseif rank == 'A' then nrank = 14
    else nrank = tonumber(rank) end

    if nrank == nil then return nil, nil end

    return suit, nrank
end

function suitToValue(suit)
    if suit == 'W' then return 6
    elseif suit == 'J' then return 5
    elseif suit == 'H' then return 4
    elseif suit == 'C' then return 3
    elseif suit == 'D' then return 2
    elseif suit == 'S' then return 1
    end

    return 0
end

function modValue(value, max)
    return ((value - 1) % max) + 1
end

-- After finding a card, if it is in a deck, take it out.
function takeCard(name)
    local card = findCard(name)

    if (card.InDeck != nil) then
        return card.InDeck.takeObject(card.Card)
    else
        return card.Card
    end
end

function findCard(name)
    return findCardIn(name, getAllObjects(), nil)
end

-- Recursively search for a card with a given name.
function findCardIn(name, souls, inDeck)
    for i,soul in ipairs(souls) do
        local soulTag = soul.tag or "NoTag"
        local soulName = soul.getName and soul.getName() or soul.name or "No Name"
        if (soulTag == 'Card' or soulTag == "NoTag") then
            if soulName == name then 
                if inDeck != nil and inDeck.tag != 'Deck' then inDeck = nil end
                return {
                    Card = soul,
                    InDeck = inDeck
                }
            end
        elseif (soulTag == 'Deck' or soulTag == 'Scripting') then
            local itemInDeck = findCardIn(name, soul.getObjects(), soul)
            if (itemInDeck != nil and itemInDeck.Card != nil) then 
                return itemInDeck
            end
        end
    end

    return {
        Card = nil,
        InDeck = nil
    }
end

function isObjectInHandZone(soul)
    for i, color in ipairs(Player.getAvailableColors()) do
        local player = Player[color]
        local handObjects = player.GetHandObjects(1)
        if handObjects != nil then 
            for i, handObject in ipairs(handObjects) do
                if handObject == soul then return color end
            end
        end
    end

    return nil
end